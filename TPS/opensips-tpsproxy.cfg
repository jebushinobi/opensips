#
# OpenSIPS residential configuration script
#     by OpenSIPS Solutions <team@opensips-solutions.com>
#
# This script was generated via "make menuconfig", from
#   the "Residential" scenario.
# You can enable / disable more features / functionalities by
#   re-generating the scenario with different options.#
#
# Please refer to the Core CookBook at:
#      http://www.opensips.org/Resources/DocsCookbooks
# for a explanation of possible statements, functions and parameters.
#

####### Global Parameters #########

log_level=3
log_stderror=no
log_facility=LOG_LOCAL1

children=4


#debug_mode=yes

/* uncomment the next line to enable the auto temporary blacklisting of 
   not available destinations (default disabled) */
#disable_dns_blacklist=no

/* uncomment the next line to enable IPv6 lookup after IPv4 dns 
   lookup failures (default disabled) */
#dns_try_ipv6=yes

/* comment the next line to enable the auto discovery of local aliases
   based on reverse DNS on IPs */
auto_aliases=no


listen=udp:78.158.48.10:5060   
listen=udp:78.158.48.10:5070

alias = tpsdialler.voiptalk.org
alias = diallerproxy.voiptalk.org
alias = vp.unitel.co.uk
alias = sipgw.unitel.co.uk

####### Modules Section ########

#set module path
mpath="/usr/local/lib64/opensips/modules/"

# SIGNALING module
loadmodule "signaling.so"

# MYSQL 
loadmodule "db_mysql.so"


loadmodule "auth.so"

# auth_db for digest auth
loadmodule "auth_db.so"
modparam("auth_db", "calculate_ha1", 0)
modparam("auth_db", "password_column", "ha1") #;Use ha1 NOT plain text for password auth. 
modparam("auth_db", "db_url", "mysql://opensips:_osipsRWuserACC_@78.158.48.11/opensips")
modparam("auth_db", "use_domain", 1) #use domains

# StateLess module
loadmodule "sl.so"


# Transaction Module
loadmodule "tm.so"
modparam("tm", "ruri_matching", 0)
modparam("tm", "fr_timeout", 30)
modparam("tm", "fr_inv_timeout", 60)
modparam("tm", "restart_fr_on_each_reply", 0)
modparam("tm", "onreply_avp_mode", 1)

# Record Route Module
loadmodule "rr.so"
modparam("rr", "append_fromtag", 1)

# Permisions module (IP auth)
loadmodule "permissions.so"
modparam("permissions","db_url", "mysql://opensips:_osipsRWuserACC_@78.158.48.11/opensips") 
modparam("permissions", "address_table", "address") 

# Dialplan
loadmodule "dialplan.so"
modparam("dialplan","db_url", "mysql://opensips:_osipsRWuserACC_@78.158.48.11/opensips")
modparam("dialplan", "table_name", "dialplan")


# MAX Forward module
loadmodule "maxfwd.so"

# SIP MSG Operations module
loadmodule "sipmsgops.so"

# FIFO Management Interface
loadmodule "mi_fifo.so"
modparam("mi_fifo", "fifo_name", "/tmp/opensips_fifo")
modparam("mi_fifo", "fifo_mode", 0666)

# URI module
loadmodule "uri.so"
modparam("uri", "use_uri_table", 0)
modparam("uri", "db_url", "mysql://opensips:_osipsRWuserACC_@78.158.48.11/opensips") 
modparam("uri", "use_domain", 1) 



# Dialog 
# Add carrier profiles to active dialog
loadmodule "dialog.so" 
modparam("dialog", "db_url", "mysql://opensips:_osipsRWuserACC_@78.158.48.11/opensips") 
modparam("dialog", "db_mode", 1) #;any dialog information changes will be reflected into the database immediately
modparam("dialog", "default_timeout", 3600) 
modparam("dialog", "profiles_with_value", "customerid ; inbound ; outbound; srcIP") 
modparam("dialog", "profiles_no_value", "carriercount") 
modparam("dialog", "dlg_match_mode", 1) #the match is first tried based on DID cookie (which is a string added to the record route header and if not present, it will fallback to SIP matching; 

#### DOMAIN module
loadmodule "domain.so"
modparam("domain", "db_url", "mysql://opensips:_osipsRWuserACC_@78.158.48.11/opensips")
modparam("domain", "db_mode", 1)

# ----- drouting params -----
loadmodule "drouting.so"
modparam("drouting", "use_domain", 0)
modparam("drouting","db_url", "mysql://opensips:_osipsRWuserACC_@78.158.48.11/opensips")
modparam("drouting", "ruri_avp", '$avp(dr_ruri)')
modparam("drouting", "gw_id_avp", '$avp(dr_gwid)') #Store the gw id in an avp 
modparam("drouting", "rule_id_avp", '$avp(dr_ruleid)')
#--- throws an error, module not loaded. 
#--- Run from dr_routing functionmodparam("drouting", "rule_attrs_avp", '$avp(rule_attrs)')
modparam("drouting", "rule_prefix_avp", '$avp(dr_rulepfx)')
modparam("drouting", "carrier_id_avp", '$avp(dr_carrierid)')

#### ACCounting module
# enable fail in do_accounting !!!
loadmodule "acc.so"
modparam("acc", "early_media", 0) # Dont count early media
modparam("acc", "report_cancels", 0) # report cancel status
modparam("acc", "detect_direction", 0)
modparam("acc","db_url", "mysql://opensips:_osipsRWuserACC_@78.158.48.11/opensips")

modparam("acc", "log_level", 2)   # Set log_level to notice - ucm is 0. Review this!

modparam("acc", "log_facility", "LOG_LOCAL2") # Alternate log file for cdrs
modparam("acc", "db_table_acc", "cdrs")
modparam("acc", "extra_fields", "log: srcIP->SrcIP; ruleprefix->Prefix")
modparam("acc", "extra_fields", "db: srcIP->SrcIP; \
                                     source->source; \
                                     destination->destination; \
                                     customer_id->customer_id; \
                                     direction->direction; \
                                     ruleprefix->Prefix; \
                                     carrier->carrier")
loadmodule "proto_udp.so"

### The module implements text based operations over the SIP message processed by OpenSIPS
loadmodule "textops.so"

### UAC auth
loadmodule "uac.so"
loadmodule "uac_auth.so"
modparam("uac","restore_mode","auto")
modparam("uac_auth","auth_realm_avp","$avp(authdomain)")
modparam("uac_auth","auth_username_avp","$avp(authuser)")
modparam("uac_auth","auth_password_avp","$avp(passwd)")


### AVpops
loadmodule "avpops.so"
modparam("avpops", "db_url", "mysql://opensips:_osipsRWuserACC_@78.158.48.11/opensips")
modparam("avpops", "avp_table", "usr_preferences")

### exec
loadmodule "exec.so"

### Pike
loadmodule "pike.so"
modparam("pike", "sampling_time_unit", 10) # default 2
modparam("pike", "reqs_density_per_unit", 35) # default 30
modparam("pike", "remove_latency", 300) # default 120


####### Route Blocks Start ########

# Main route 
route{
        # Add extra logging with a setflag.
        setflag(LOGXTRA);
        if (isflagset(LOGXTRA)){xlog("SIP Request. METHOD: $rm URI: $ru CALL-ID $ci\n");}
        else{ 
		xlog("SIP Request received: $rm URI: $ru\n"); 
	}

	#If source IP is not on the trusted list and pike check returns positive, drop the packet.  
        if (    !is_myself("$si")  &&
                $si != 217.14.138.0/24 &&
                $si != 77.240.48.0/20 &&
                $si != 78.158.48.0/20 &&
                !pike_check_req()
        )
        	{
                	xlog("L_ALERT","ALERT: pike block $rm from $fu (IP:$si) RETURN CODE $rc \n");
                	$var(ip) = $si+'|'+$ua;
                	exec("/bin/python3 /scripts/opensips/ddos/pikeblock.py","$var(ip)","$var(out)", "$var(err)");
                	;xlog("OUTPUT from exec command $var(out) $var(err) $var(ip)");
                	exit;
        	};

        #If max fwd header is not found, set to 10 and carry on processing, if maxfwd is found with a positive value, return code is 'true' and value is decremented. Carry on processing. 
        #If found and value is 0, return code is false (-1), we send a 483 reply and exit. 
        if (!mf_process_maxfwd_header("10")) {
                sl_send_reply("483","Too Many Hops");
                exit;
        }

        #Check if sequential request. (to tag present) which indicates it belongs to a pre-existing transaction. 
        #For an existing transaction. 
        if (has_totag()) {
                # XARIOS PATCHES START //// 
        	if ( is_method("ACK") ) {
                        if ($ou=~"^sip:049074416181315.*@.*") {
                                if(remove_hf("Date"))
                                {
                                        # Date header removed
                                        xlog("Removed date header for xarios for ACK $ou");
                                }
                        }
                }

                if ( is_method("BYE") ) {
                        #Patch for Xarios gmt Date HF
                        if ($ou=~"^sip:049074416181315.*@.*") {
                                if(remove_hf("Date"))
                                {
                                        # Date header removed
                                        xlog("Removed date header for xarios BYE for $ou");
                                }
                        }
                }

                # XARIOS PATCHES END ////

                # Sequential requests should follow route set. else send 404
                if (loose_route()) {
                        #Add route set on re-INVITEs, some buggy clients change route set during the dialog.
                        #Add again to be sure
                	if (is_method("INVITE")) {
                                record_route();
                        }
                        #If route set is found,continue processing in relay route block 
                        #for processing sequential requests.
                	route(relay); 
                } else {
                        if ( is_method("ACK") ) {
                                #t_check_trans will return true, if an ACK belongs to a known transaction.  
                                #If an ACK is not to a 200 OK it will be in the same transaction                       
                        	if ( t_check_trans() ) {
                                        xlog("L_ERR","ACK: No record route\n");
                                        t_relay();
                                        exit;
                                }                                
                                else {
                                        # Discard the ACK if no record route and not part of an existing transaction. 
                                        exit;
                                }
                        }       
                }    
                #Has totag but failed loose_route and not an ACK. 
                sl_send_reply("404","Not here");
                xlog("Request Dropped, UFO traffic. 404 sent");
                exit;
	}


	if (is_method("CANCEL"))
        {     
                #Check if this CANCEL matches an existing transaction, if it does relay it.                
                if (t_check_trans()) {
                        t_relay();
                }
                # if not, simply drop it
                exit;
        }


        # for non-CANCEL/ACK requests - Function checks if the request is a retransmission belonging to a stateful transaction. 
        # If it is, the function will auto process the retransmission and exit. 
	# The function returns false and carries on processing if req is not a retransmission.
        t_check_trans();

        # Route set found with no to-tags. This implies a new transaction with record routes already set. 
        # This is used for preloaded routes. We do not support this so discard. 
        if (loose_route()) {
                xlog("L_ERR","Attempt to route with preloaded Route's [$fu/$tu/$ru/$ci]");
                if (!is_method("ACK"))
                        sl_send_reply("403","Preload Route denied");
                exit;
        }

        # Finally here, New Requests //////////////////////////////////////////////////////////////////////////////////
        #### NEW REQUEST ####
        if (isflagset(LOGXTRA)){xlog("SIP Request is NEW. CALL-ID $ci UA $ua \n");}
	# record routing for all non REGISTER/MESSAGE requests
        # No need to record route for REGISTERS because we are not proxying them. 
        if (!is_method("REGISTER|MESSAGE"))
                record_route();
 
	if (is_method("PUBLISH"))
        {
                sl_send_reply("503", "Service Unavailable");
                exit;
        }

	#Drop REGISTERS
        if (is_method("REGISTER"))
        {
                sl_send_reply("503", "Service Unavailable");
                exit;
        }
    
        if ($rU==NULL) {
                # request with no Username in RURI. Send stateless reply.
                sl_send_reply("484","Address Incomplete");
                exit;
        }
       
        #Inbound calls arrive on port 5060, Outbound on 5070.

        #Set direction and jump to direction block.
	if($Rp==5060)
        {
                xlog("Inbound call to $rU from domain $fd SourceIP $si switching to Inbound routeblock");
                $avp(direction)="I";
                route(INC);
        }

        #Outbound calls arrive on port 5070
        #Reroute to outbound block.
        if($Rp==5070)
        {
                xlog("Outbound call to $rU switching to Outbound routeblock");
                $avp(direction)="O";
                route(OUT);
        }
}

#### INBOUND CALLS ####
route[INC] {
	# Dialplan functions. Strip leading +'s and replace UK national format with E164
	# if($rU=~"^\+"){ strip(1); }
	# if($rU=~"^0[1-9]"){strip(1);prefix("44"); }
        dp_translate("20", "$rU/$rU"); 
        dp_translate("20", "$rU/$rU"); 
        if (isflagset(LOGXTRA)){xlog("ROUTE BLOCK: INBOUND Dialplan translate. rU to $rU\n");}

        #Cli presentation        
        $avp(clip)=$fU;

	#Identify customerid, get dialog timeout and debug params.
        avp_db_query("SELECT customer_id FROM opensips.customers_cli WHERE cli='$rU'","$avp(sipuserid)");
        if ($avp(sipuserid)) {
        	avp_db_query("SELECT dlg_timeout_inbound,enable_opensips_debug FROM opensips.customers WHERE customer_id=$avp(sipuserid)","$avp(dlg_timeout);$avp(debug)");
                } 
 
        #INSERT X-DBG header if enable debug column is set to 'Y'. 
        if($avp(debug)=="Y") {
                xlog("Route INBOUND - rU=$rU dlg_timeout=$avp(dlg_timeout) customer_id=$avp(sipuserid)");
                insert_hf("X-DBG: 1\n");
                }

        ### Verify customerid is populated, query db for calllimit and store in call_limit variable. 
        # Create dialog and add direction and call limit to the profile.  
        if(is_avp_set("$avp(sipuserid)")) {
        	avp_db_query("SELECT trunks FROM opensips.customers WHERE customer_id=$avp(sipuserid)","$avp(call_limit)");

                #Create dialog and add profile for concurrent calls
                create_dialog("B"); 
                set_dlg_profile("customerid","$avp(sipuserid)"); 
                set_dlg_profile("inbound","$avp(sipuserid)");
                store_dlg_value("cid","$avp(sipuserid)");
                store_dlg_value("caller","$fu");
                store_dlg_value("callee","$ru");
                if($avp(log_missed_calls)==1) {
                	setflag(DB_MISSED_FLAG);
                        } 
                #get call limit, compare active channels with limit. 
		if (is_avp_set("$avp(call_limit)")) {
                        #Get count on 'customerid' profile where value matches '$avp(sipuserid)' and store the result in '$avp(active_channels)'  
                        get_profile_size("customerid","$avp(sipuserid)","$avp(active_channels)");
                        if($avp(debug)=="Y") { xlog("Incoming call. Customer ID $avp(sipuserid) is using $avp(active_channels) channel(s), maximum=$avp(call_limit)"); }
			#String transform to int value. Run a check if active_channels > call_limit
                        if($(avp(active_channels){s.int})>$(avp(call_limit){s.int})) {
                                sl_send_reply("486", "Busy Here");
                                exit;
                        }
                }                
                #+++ Add a is flag set to only log missed table if the flag is set.
                #Go to cdrs and mark cdr flag active. 
                route(cdrs); 
	} else {
                # We cant link the call to a customer, drop.
		# Look at sending to an asterisk box to play a message. 
                if (isflagset(LOGXTRA)){xlog("Cannot find CustomerID dropping INVITE");}
                sl_send_reply("404", "Not Found");
                exit;
        }
       

	if (is_method("REGISTER")) {
                sl_send_reply("603", "Declined - no bueno!");
        };

        #Check Source IP against incoming carrier group '2'
        # if not in table send a 488 MSG. 
        if (check_address("2","$si","0","$proto")) {
		if (is_method("INVITE")) {
                	xlog("Source IP authenticated");
                        #Patch for Xarios gmt Date HF ////
                        if ($ou=~"^sip:\+4416181315.*@.*") {
                                if(remove_hf("Date"))
                                {
                                	# Date header removed
                                        xlog("Removed date header for xarios INVITE for $ou");
                                }
                        }
                        #////
                        #Look up avp table 'usr_preferences' for destination to forward call.i 
                        # Push to destination uri.
                        avp_db_load("$ruri","$avp(callfwd)");
                        avp_pushto("$ruri","$avp(callfwd)");
                        if ($avp(callfwd)){
                        	if($avp(debug)=="Y") { xlog("Using AVP - $avp(callfwd)"); }
                        	route(relay);
                        }                        
                        else {
                          	xlog("Inbound call: NO forward destination found, dropping\n");
                                sl_send_reply("404", "Not Found");   
                                exit;
                             }
                        
                };

                #If its a CANCEL, relay without db checks
        	if(is_method("CANCEL")) {
                	route(relay);
                };

                if(is_method("BYE")) {
                        #Patch for Xarios gmt Date HF ////
                        if ($ou=~"^sip:\049074416181315.*@.*") {
                                if(remove_hf("Date"))
                                {
                                        # Date header removed
                                        xlog("Removed date header for xarios BYE for $ou");
                                }
                        }
                        #////
                	route(relay);
                };

        } else
             {  
                #IP auth failed
                if (isflagset(LOGXTRA)){xlog("INBOUND CALL: IP auth failed for source IP $si");}  
                sl_send_reply("488", "Not Acceptable Here");
                exit;
             };

}


route[OUT] {
        #Check SRCIP against address table, outbound is carrier group 1. 
	if (!check_address("1","$si","0","$proto")) {
                xlog("Outbound Route block: Failed IP Authentication for IP $si");   
                sl_send_reply("403", "Forbidden");
                exit;
        }

        #Check for CIP X HEADER as alternative Subscriber SOURCE ip identifier. 
	# $avp(cip) is where the SRC IP is stored and referenced. 
        if(is_present_hf("X-CIP")){
                if($avp(debug)=="Y") { xlog("X-CIP header found"); }
                $avp(cip)=$hdr(X-CIP);
                if($avp(debug)=="Y") { xlog("SUBSCRIBER SOURCE IP(CIP) =$avp(cip)"); }
        } else {
                $avp(cip)=$si;
        }


	#//// CALLERID checks
	#Check to see if its witheld
        if($rU=~"^141."){
                strip(3);
                setflag(WITHELD);
        }

        #Check for RPID. If found, remove and replace with PAID.   
        if(is_present_hf("Remote-Party-ID")){
                if (isflagset(LOGXTRA)){xlog("OUTBOUND block: RPID HEADER METHOD: $rm URI: CALL-ID $ci\n $hdr(Remote-Party-ID)");}
                $avp(rpid)=$hdr(Remote-Party-ID);
                #URI transform on the RPID address variable '$re' to get the user and domain values.
                $avp(rpid-user)=$(re{uri.user});
                $avp(rpid-domain)=$(re{uri.host});

                # Remove the RPID header
                remove_hf("Remote-Party-ID");
                # Check if CLI set to withheld
                if($(avp(rpid){nameaddr.param,privacy})=="full"){
                        setflag(WITHELD);
                }
                #Set outbound cli FROM and PAID headers.
                $avp(clip)=$avp(rpid-user);
		$avp(cliPAID)=$re;

        } else {
		#If no RPID header set, use the FROM header.
                $avp(clip)=$fU;
		$avp(cliPAID)=$fu;
        }

	#Set callerid via PAID header			        
	if(is_present_hf("P-Asserted-Identity")) {
                      if (isflagset(LOGXTRA)){xlog("PAID header $hdr(P-Asserted-Identity) found on SIP Request METHOD: $rm URI: $ru CALL-ID $ci\n");}
                      setflag(PAIDSET);
		      #$ai is the variable where the URI for the PAID header is stored. 
		      #Set outbound cli
                      $avp(clip)=$(ai{uri.user});
        } else {
		append_hf("P-Asserted-Identity: <$avp(cliPAID)>\r\n");
	}	

        if (isflagset(LOGXTRA)) { xlog ("Cli for call will be $avp(clip) PAID header $avp(cliPAID)"); }
        
        if($rU=~"^\+"){
                strip(1);
        }

        #/////////

        if($avp(debug)=="Y") { xlog("rU=$rU"); }
	#Set dial format to E164
        if($rU=~"^0[1-9].") {
                strip(1);
                prefix("44");
		if (isflagset(LOGXTRA)) { xlog ("UK Destination reset to E164. New destination $rU"); }
        }
     
        if($rU=~"^00[1-9].") {
                strip(2);
		if (isflagset(LOGXTRA)) { xlog ("Destination reset to E164. New destination $rU"); }
        }

        #Find SIP HEADER 'X-ROUTE-TAG'
	#XARIOS for instance tag all there calls with 'X-ROUTE-TAG: UKD'
	#This is an additional layer for identifying the source. 
        $avp(gw_tag)=$hdr(X-ROUTE-TAG);
        if($avp(gw_tag)==NULL){
                $avp(gw_tag)="";
        };

        #Try IP Authentication
        if(!is_avp_set("$avp(sipuserid)")) {
# EX CALL sp_auth_ip('217.14.138.82','')
#+-------------+----------------+------------------------+--------+---------------+--------------+-------------+-----------------------+------------------+--------------+---------+----------------+----------------+
#| customer_id | trunk_group_id | secondary_trunk_groups | trunks | allow_any_cli | default_cli  | dlg_timeout | enable_opensips_debug | log_missed_calls | record_calls | dialler | vtalk_username | vtalk_password |
#+-------------+----------------+------------------------+--------+---------------+--------------+-------------+-----------------------+------------------+--------------+---------+----------------+----------------+
#|          47 |             16 | 9,10,11                | 300    |             1 | 441905388000 |        3600 | Y                     |                0 |            0 |       1 | 7493937        | eM!62Nuf34     |
#+-------------+----------------+------------------------+--------+---------------+--------------+-------------+-----------------------+------------------+--------------+---------+----------------+----------------+
# EX - Xarios use the gw_tag value 'UKD' CALL sp_auth_ip('78.158.49.41','UKD');

		#IP auth identifier table: opensips_customers_ip_address.
		#Customers table is customers.
		#Call stored procedure, returned values (including customerid) go into the avps.
		avp_db_query("CALL sp_auth_ip(\"$avp(cip)\",\"$avp(gw_tag)\")","$avp(sipuserid);$avp(trunkgroup);$avp(trunkgroups);$avp(call_limit);$avp(allow_any_cli);$avp(default_cli);$avp(dlg_timeout);$avp(debug);$avp(log_missed_calls);$avp(record_calls);$avp(dialler);$avp(vtalk_username);$avp(vtalk_password)");
                xlog("IP Authcheck for IP $avp(cip) - CID=$avp(sipuserid) Trunk group=$avp(trunkgroup) Secondart trunkgroups=$avp(trunkgroups) CallLimit=$avp(call_limit)");
                xlog("IP Authcheck - AllowCLI=$avp(allow_any_cli) DefaultCLI=$avp(default_cli) Dialog timeout=$avp(dlg_timeout) REC_CALLS=$avp(record_calls)");
                xlog("IP Authcheck - LOG_MISSED_CALLS=$avp(log_missed_calls) GW Tag=$avp(gw_tag) DIALLER=$avp(dialler) VTALK_USERNAME=$avp(vtalk_username) VTALK_PASSWORD=$avp(vtalk_password)");
                } 

		if(!is_avp_set("$avp(sipuserid)")) {
                	xlog("Trying Subscriber Auth for - $avp(cip)");
                        if (!www_authorize("$avp(cip)","subscriber")) {
                                xlog("AUTH FAIL");
				#Send auth challenge and exit
                                www_challenge("$avp(cip)", "1");
                             };
                        xlog("AUTH USER $au");
                        avp_db_query("CALL sp_auth_subscriber(\"$au\")","$avp(sipuserid);$avp(trunkgroup);$avp(trunkgroups);$avp(call_limit);$avp(allow_any_cli);$avp(default_cli);$avp(dlg_timeout);$avp(debug);$avp(log_missed_calls);$avp(record_calls);$avp(dialler);$avp(vtalk_username);$avp(vtalk_password)");
                }

        # Check if customer is allowed to send own cli  
        # If allowed, check if $avp(clip) is on customer cli list. If not set cli to the default. 
        if(is_avp_set("$avp(sipuserid)") && ($avp(allow_any_cli)==0)) {
                avp_db_query("SELECT count(*) FROM customers_cli WHERE customer_id=$avp(sipuserid) AND cli=\"$avp(clip)\"","$avp(cli_allowed)");
                if($avp(debug)=="Y") { xlog("Check CLI $fU - cli_allowed=$avp(cli_allowed)"); }
    
                xlog("Check CLI $fU - cli_allowed=$avp(cli_allowed)");
                if($(avp(cli_allowed){s.int})==0) {
                        if($avp(debug)=="Y") { xlog("Setting Default CLI - Customer = $avp(sipuserid) CLI = $avp(default_cli)"); }
                        setflag(SET_DEFAULT_CLI); #used to set default cli in carrier route blocks 
			#else use the curent CLI
                        $avp(clip)=$avp(default_cli);
                }
        }
        ### remove xlog("RECORD ROUTE HEADERS $(hdrcnt(Record-Route))");
	#Check against TPS database
	#Check if TPS header is present.
	if(is_present_hf("X-TPS")) {
        	$avp(tpsheader)=$hdr(X-TPS);
		#If tpsheader value is set to 'true'
                if($avp(tpsheader)=="true") {
                	if($avp(debug)=="Y") { xlog("TPS header FOUND"); }
                        #--- Remove dup xlog
                	xlog("TPS header FOUND CALL sp_outbound_screen($avp(sipuserid),$rU,$fU)"); 
                        # the 3rd argument in the stored procedure is actually not needed. Remove in future version. 
                        avp_db_query("CALL sp_outbound_screen($avp(sipuserid),$rU,$fU)","$avp(tpsallow)");
                        if($avp(debug)=="Y") { xlog("TPS - $rU for customer $avp(sipuserid) - value = $avp(tpsallow)"); }
                        if ($avp(tpsallow)==1) {
                        	if($avp(debug)=="Y") { xlog("DESTINATION ON TPS Send 404 Service Unavailable TPS"); }
                                sl_send_reply("404", "Service Unavailable TPS");
                                exit;
                        }
                }
        }

        ### Only route if we know the customer id
	if(is_avp_set("$avp(sipuserid)")) {
        ### Create dialog and add profile for concurrent calls
        	if(create_dialog("B") && set_dlg_profile("customerid","$avp(sipuserid)")) {
                	set_dlg_profile("outbound","$avp(sipuserid)");
                	store_dlg_value("cid","$avp(sipuserid)");
                	store_dlg_value("caller","$fu");
                	store_dlg_value("callee","$ru");
                	if($avp(log_missed_calls)==1) {
                        	setflag(DB_MISSED_FLAG);
                	}
        	}
        
		### Check max concurrent calls not exceeded
		if (is_avp_set("$avp(call_limit)")) {
                        #profile customerid, get the len where the value = sipuserid 
        		get_profile_size("customerid","$avp(sipuserid)","$avp(active_channels)");
                	if($avp(debug)=="Y") { xlog("Trunk Usage - customer_id=$avp(sipuserid) using $avp(active_channels) channel(s), maxiumum=$avp(call_limit)"); }
                        #String transform to integer and do a comparison. 
                	if($(avp(active_channels){s.int}) > $(avp(call_limit){s.int}) ) {
                		sl_send_reply("504", "Maximum concurrent call limit reached");
			        if (isflagset(LOGXTRA)){xlog("OUTBOUND route block - Maximum concurrent call limit reached User: $avp(sipuserid) Call count: $avp(active_channels) Limit $avp(call_limit)");}
                        	exit;
                        }
        	}
		#Check dynamic routing table.
		if(!do_routing("$avp(trunkgroup)","W",,"$avp(rule_attrs)","$avp(gwdest_attrs)")){
                	if($avp(debug)=="Y") { xlog("do_routing - failed for $fU"); }
                        send_reply("488", "No rules found matching the URI prefix");
                        if($avp(debug)=="Y") { xlog("do_routing failed to find rules for $rU"); }
                    	exit;
                    }
                else {                
                	xlog("Outbound route attributes: GroupID $avp(trunkgroup) Rule $avp(rule_attrs) RULEID $avp(dr_ruleid) GW $avp(gwdest_attrs) Secondary URI $avp(dr_ruri) GWID $avp(dr_gwid) PFX $avp(dr_rulepfx) CARRIERID $avp(dr_carrierid)"); 
                }     
        }

 	#Check UK number length  
	if($rU=~"^44") {
                if(is_avp_set("$avp(rule_attrs)")) {
    			if($(rU{s.len})<11 || $(rU{s.len})>12) {
                        	xlog("$rU is $(rU{s.len}) digits long");
                                sl_send_reply("404", "Invalid number");
                                exit;
                        }
                }
        }

        #Try routing to 1st carrier, 'on failure' route checks for flag AVAILFAILOVER and if set, search for next GW
        setflag(AVAILFAILOVER);
        if($avp(debug)=="Y") { xlog("[Main] routing to via Trunk $avp(dr_gwid)"); }

        # Send to carrier
	switch($avp(dr_gwid))
        	{
		case "t95":
                        route(relay);
                        break;
		case "t93":
                        route(relay);
                        break;
                case "t98":
                        setflag(LOADTEST);
                	route(relay);
                        break;
		case "10":
 	             	route(voiptalk);
                        break;
                case "9":
                	route(nexbridge);
                        break;
                case "15":
                 	route(VoipTalkDialler);
                        break;
                default:
                        xlog("OUTBOUND Route block - Unable to find route\n");
	}        
        exit;
}	

#VoipTalk
route[voiptalk] {
        # ARM reply routes
        if (is_method("INVITE")) {
                 t_on_failure("voiptalk");
                 t_on_reply("voiptalk");
                 t_on_branch("voiptalk");
        }
	#Set carrier name
        $avp(carrier)="VoipTalk";
        if($avp(debug)=="Y") { xlog("GWID 10 Call to $rU via VoipTalk from $fU"); }

        if (!t_relay()) {
                sl_reply_error();
        };

        exit;
}

branch_route[voiptalk] {
        xlog("Branch Route $avp(carrier) ru $ru");
        if($avp(debug)=="Y") { xlog("[10] Branch rU=$rU fU=$fU Cli=$avp(clip)"); }

        #E164 + format.
        if(!$rU=~"\+") {
                prefix("+");
        }

        if(!$tU==$rU) {
                $var(t_hf) = "sip:" + $rU + "@" + $fd + ":" + $rp;
                uac_replace_to("$var(t_hf)");
        }

        if(isflagset(WITHELD)){
                insert_hf("Remote-Party-ID: <sip:$avp(clip)@$fd>;privacy=full;screen=yes\n");
        } else {
		append_hf("P-Asserted-Identity: <$re>\r\n");
                insert_hf("Remote-Party-ID: <sip:$avp(clip)@$fd>;privacy=off;screen=yes\n");
        }
    
}

onreply_route[voiptalk] {
        xlog("$avp(carrier) Reply block - M=$rm RR=$rr RS=$rs RURI=$ru F=$fu T=$tu IP=$si ID=$ci\n");

        if(!is_present_hf("X-CID")) {
                fetch_dlg_value("cid", "$avp(sipuserid)");
                insert_hf("X-CID: $avp(sipuserid)\r\n", "Call-ID");
        }

        if($avp(record_calls)==1) {
                insert_hf("X-REC: $avp(record_calls)\n");
        }
        if($avp(debug)=="Y") {
                insert_hf("X-DBG: 1\n");
        }
}

failure_route[voiptalk] {
        xlog("$avp(carrier) failure block - M=$rm RR=$rr RS=$rs RURI=$ru F=$fu T=$tu IP=$si ID=$ci\n");

        if($avp(debug)=="Y") { xlog("Failure Route 10 M=$rm RURI=$ru F=$fu T=$tu IP=$si ID=$ci\n"); }

        #If BUSY forward it to uac
        if ( t_check_status("486") )
        {
                if($avp(debug)=="Y") { xlog("$avp(carrier) failure block - 486 - Busy - $rU"); }
                t_reply("486", "Busy, Please try later");
                exit;
        }
   
        if ( t_check_status("404|484") )
        {
                if($avp(debug)=="Y") { xlog("$avp(carrier) failure block Sent 404 - Invalid"); }
                t_reply("404", "Invalid Number");
                exit;
        }

        if ( t_check_status("408") )
        {
                if($avp(debug)=="Y") { xlog("$avp(carrier) failure block Sent 408 - Request Timeout - $rU"); }
                t_reply("408", "Request timeout");
                exit;
        }

        #Voiptalk digest auth with uac module
        if(t_check_status("407"))
        {
                $avp(authdomain)="sip.voiptalk.unitel.co.uk";
                $avp(authuser)=$avp(vtalk_username);
                $avp(passwd)=$avp(vtalk_password);
                if($avp(debug)=="Y") { xlog("[10]Failure Route VoipTalk - authuser=$avp(11), authpass=$avp(12)"); }
                route(cdrs);
                xlog("BACK FROM ENABLE ACCOUNT");
                uac_auth();
                #FLAG: 0x04 - disable the DNS failover for the transaction. 
                #Only first IP will be used. It disables the failover both at transport and transaction level.
                t_relay("0x04");
                exit;
        }

        #Route to next gateway on failure
        if($avp(debug)=="Y") { xlog("$avp(carrier) failure block - About to try next GW"); }

        if(isflagset(AVAILFAILOVER)){
                if (use_next_gw()) {
                        if($avp(debug)=="Y") { xlog ("$avp(carrier) failure block next gateway $ru \n"); }
                        setflag(30);
                        t_on_failure("voiptalk");
                        switch($avp(dr_gwid))
                        {
				case "10":
                                	route(voiptalk);
                                	break;
			                case "9":
                                case "9":
                                	route(nexbridge);
                        		break;
                		case "15":
                        		route(VoipTalkDialler);
                        		break;
                		default:
                        		xlog("OUTBOUND Route block - Unable to find route\n");
                        }
                        exit;
                }
                else {
                        t_reply("503", "Service not available, no more gateways");
                        exit;
                }
        }
}


#VoipTalkDialler
route[VoipTalkDialler] {
        # ARM reply routes
        #### look into this --- $avp(trunk)="15";
        if (is_method("INVITE")) {
                 t_on_failure("VoipTalkDialler");
                 t_on_reply("VoipTalkDialler");
                 t_on_branch("VoipTalkDialler");
        }

        $avp(carrier)="VoipTalkDialler";
        if($avp(debug)=="Y") { xlog("Carrier $avp(carrier) Call to $rU from $fU"); }
        xlog("Carrier - $avp(carrier) Call to $ru from $fU"); 

        if (!t_relay()) {
                sl_reply_error();
        };

        exit;
}


branch_route[VoipTalkDialler] {
        xlog("Branch Route $avp(carrier) ru $ru");
        if($avp(debug)=="Y") { xlog("Carrier $avp(carrier) Branch rU=$rU fU=$fU Cli=$avp(clip)"); }

        #Send as UK National.
        if($rU=~"^44") {
                strip(2);
                prefix("0");
        }
      
        #to user should match request uri user
        if(!$tU==$rU) {
                $var(t_hf) = "sip:" + $rU + "@" + $fd + ":" + $rp;
                uac_replace_to("$var(t_hf)");
        }

        if(isflagset(WITHELD)){
                insert_hf("Remote-Party-ID: <sip:$avp(clip)@$fd>;privacy=full;screen=yes\n");
        } else {
                insert_hf("Remote-Party-ID: <sip:$avp(clip)@$fd>;privacy=off;screen=yes\n");
        }
}


onreply_route[VoipTalkDialler] {
        xlog("$avp(carrier) Reply block - M=$rm RR=$rr RS=$rs RURI=$ru F=$fu T=$tu IP=$si ID=$ci\n");

        if(!is_present_hf("X-CID")) {
                fetch_dlg_value("cid", "$avp(sipuserid)");
                insert_hf("X-CID: $avp(sipuserid)\r\n", "Call-ID");
        }

        if($avp(record_calls)==1) {
                insert_hf("X-REC: $avp(record_calls)\n");
        }
        if($avp(debug)=="Y") {
                insert_hf("X-DBG: 1\n");
        }
}



failure_route[VoipTalkDialler] {
        xlog("$avp(carrier) failure block - M=$rm RR=$rr RS=$rs RURI=$ru F=$fu T=$tu IP=$si ID=$ci\n");
        if($avp(debug)=="Y") { xlog("$avp(carrier) failure block -  M=$rm RURI=$ru F=$fu T=$tu IP=$si ID=$ci\n"); }
        
        if ( t_check_status("486") )
        {
                if($avp(debug)=="Y") { xlog("$avp(carrier) failure block - 486 - Busy - $rU"); }
                t_reply("486", "Busy, Please try later");
                exit;
        }

        if ( t_check_status("404|484") )
        {
                if($avp(debug)=="Y") { xlog("$avp(carrier) failure block Sent 404 - Invalid"); }
                t_reply("404", "Invalid Number");
                exit;
        }
        if ( t_check_status("408") )
        {
                if($avp(debug)=="Y") { xlog("$avp(carrier) failure block Sent 408 - Request Timeout - $rU"); }
                t_reply("408", "Request timeout");
                exit;
        }


        if(t_check_status("407"))
        {
                $avp(authdomain)="dialler.voiptalk.unitel.co.uk";
                $avp(authuser)=$avp(vtalk_username);
                $avp(passwd)=$avp(vtalk_password);
                if($avp(debug)=="Y") { xlog("$avp(carrier) Failure Route VoipTalk - authuser=$avp(11), authpass=$avp(12)"); }
                route(cdrs);
                uac_auth();
                #FLAG: 0x04 - disable the DNS failover for the transaction.
                #Only first IP will be used. It disables the failover both at transport and transaction level.
                t_relay("0x04");
                exit;
        }

 #Route to next gateway on failure
        if($avp(debug)=="Y") { xlog("$avp(carrier) failure block - About to try next GW"); }

        if(isflagset(AVAILFAILOVER)){
        	if (use_next_gw()) {
                	if($avp(debug)=="Y") { xlog ("$avp(carrier) failure block next gateway $ru \n"); }
                        setflag(30);
                        t_on_failure("VoipTalkDialler");
                        switch($avp(dr_gwid))
                        {
                                case "10":
                                        route(voiptalk);
                                        break;
                                case "9":
                                        route(nexbridge);
                                        break;
                                case "15":
                                        route(VoipTalkDialler);
                                        break;
                                default:
                                        xlog("OUTBOUND Route block - Unable to find route\n");
                        }
                        exit;
                }
                else {
                        t_reply("503", "Service not available, no more gateways");
                        exit;
                }
        }
}


route[relaytest] {
	# for INVITEs enable some additional helper routes
	if (is_method("INVITE")) {
	#	t_on_branch("per_branch_ops");
	#	t_on_reply("handle_nat");
        #	t_on_failure("missed_call");
	}

        xlog("L_INFO"," Route relay block - New Request - Method - $rm: URI - $ru SRCIP $si UA $ua\n");
	if (!t_relay()) {
		send_reply("500","Internal Error");
	}
	exit;
}

route[carrier_set]{
	switch($avp(dr_gwid))
        	{                	
			case "t95":
                                $avp(carrier_x) = 'relay';
                                break;
			case "t93":
                                $avp(carrier_x) = 'relay';
                                break;
			case "10":
                        	$avp(carrier_x) = 'voiptalk';
			        break;
                        case "9":
                        	$avp(carrier_x) = 'nexbridge';
                                break;
			case "15":
				$avp(carrier_x) = 'VoipTalkDialler';
				break;                                
			default:
                                $avp(carrier_x) = 'default';
                               	xlog("OUTBOUND Route block - Unable to find route\n");
		}
}

# Outbound transmission block. t_relay()
# If not already added, INJECT headers
# Arm reply route and failure route.
route[relay] {
        if (isflagset(LOGXTRA)){xlog("Route Relay block. $rm $ru $ci\n");}
        if($avp(debug)=="Y") { xlog(" Call to $rU from Customer $avp(sipuserid)"); }
   
        #///Xarios Date field patch
        if ($ou=~"^sip:049074416181315.*@.*") {
                xlog("Set ONREPLY for Xarios call $ou");
                #CHANGE THIS ON REPLY ROUTE
                t_on_reply("RX");
        }
       #////

        #CHANGE THIS FAILURE ROUTE
        if (is_method("INVITE")) {
                t_on_failure("RX");
        }

        if(isflagset(LOADTEST)){route(cdrs);}

        #relay section
        if (!t_relay()) {
                sl_reply_error();
        };
        exit;
}


onreply_route[RX] {
        # xlog("[1]incoming reply\n - $tU");
        if(!is_present_hf("X-CID")) {
                fetch_dlg_value("cid", "$avp(sipuserid)");
                insert_hf("X-CID: $avp(sipuserid)\r\n", "Call-ID");
        }

        if($avp(record_calls)==1) {
                insert_hf("X-REC: $avp(record_calls)\n");
        }

        if ($rs =~ "(183)|(2[0-9][0-9])" )
        {
                if($avp(debug)=="Y") { xlog(" RX block Reply Xarios rewrite"); }
                if(remove_hf("Date"))
                {
                        # Date header removed
                        if($avp(debug)=="Y") { xlog("Removed date header for xarios for $si to $ou"); }
                }
        }
}

failure_route[RX] {
        if($avp(debug)=="Y") { xlog(" Failure Route RX"); }

        #Route to next gateway on failure
        if(isflagset(AVAILFAILOVER)){
        if($avp(debug)=="Y") { xlog("[1]About to try next GW"); }
                if (use_next_gw()) {
                        if($avp(debug)=="Y") { xlog ("[1]next gateway $ru \n"); }
                        t_on_failure("RX");
                        t_relay();
                        exit;
                }
                else {
                        t_reply("503", "Service not available, no more gateways");
                        exit;
                }
        }

}

#Enable accounting and go back to the parent route block.
route[cdrs]{
	xlog("Enable ACCOUNTING \n");
        if (!$avp(direction)){
		if($Rp==5060){$avp(direction)="I";}
        	if($Rp==5070){$avp(direction)="O";}
        }
        do_accounting("log|db","cdr|missed");
        $acc_extra(srcIP) = $si;
        $acc_extra(source) = $fU;
        $acc_extra(destination) = $rU;
        $acc_extra(customer_id) = $avp(sipuserid);
        $acc_extra(direction) = $avp(direction);
}


failure_route[dr_fail] {
        xlog("Failure route. $ru Dialog fail reason: $DLG_end_reason");
        if (t_check_status("404")) {
            xlog("t_fail 404 NOT FOUND");
        }
        xlog("t_fail");
        if (use_next_gw()) {    
            xlog ("next gateway is $ru \n");    
            t_on_failure("dr_fail");    
            t_relay();    
            exit;  
        } 
        else {    
            t_reply("503", "Service not available");    
            xlog ("503 not found - exhausted alternative \n");
            exit;  
        }
}       
    
failure_route[missed_call] {
	if (t_was_cancelled()) {
		exit;
        }
	# uncomment the following lines if you want to block client 
	# redirect based on 3xx replies.
	##if (t_check_status("3[0-9][0-9]")) {
	##t_reply("404","Not found");
	##	exit;
	##}
}

#Test only--->
local_route {
        xlog("Local route, end reason: $DLG_end_reason status: $DLG_status Variabletest $dlg_val(caller) sourceIP count: $var(srcIP) $dlg_val(srcIP)");
        if (is_dlg_flag_set("10")) {
                xlog("Dialog call completed");
           }
}



#NexBridge
route[nexbridge] {
        $avp(trunk)="nexbridge";
        # ARM reply routes
        if (is_method("INVITE")) {
                 t_on_failure("nexbridge");
                 t_on_reply("nexbridge");
                 t_on_branch("nexbridge");
        }

        $avp(carrier)="Nexbridge";
        if($avp(debug)=="Y") { xlog("$avp(carrier) Call to $rU via Nexbridge from $fU"); }

        if (!t_relay()) {
                sl_reply_error();
        };

        exit;
}

branch_route[nexbridge] {
        if($avp(debug)=="Y") { xlog("Branch Route $avp(carrier) ru $ru"); }

        if(!$rU=~"^\+") {
                prefix("+");
        }

        if(!$tU==$rU) {
                $var(t_hf) = "sip:" + $rU + "@" + $fd + ":" + $rp;
                uac_replace_to("$var(t_hf)");
        }

        if(!$avp(clip)=~"^\+"){
                $avp(clip)="+" + $avp(clip);
        }

        if(isflagset(WITHELD)){
                insert_hf("Remote-Party-ID: <sip:$avp(clip)@$fd>;privacy=full;screen=yes\n");
        } else {
                insert_hf("Remote-Party-ID: <sip:$avp(clip)@$fd>;privacy=off;screen=yes\n");
        }
}



onreply_route[nexbridge] {

        xlog("$avp(carrier) Reply block - M=$rm RR=$rr RS=$rs RURI=$ru F=$fu T=$tu IP=$si ID=$ci\n");

        if(!is_present_hf("X-CID")) {
                fetch_dlg_value("cid", "$avp(sipuserid)");
                insert_hf("X-CID: $avp(sipuserid)\r\n", "Call-ID");
        }

        if($avp(record_calls)==1) {
                insert_hf("X-REC: $avp(record_calls)\n");
        }
        if($avp(debug)=="Y") {
                insert_hf("X-DBG: 1\n");
        }
}

failure_route[nexbridge] {
        xlog("$avp(carrier) failure block - M=$rm RR=$rr RS=$rs RURI=$ru F=$fu T=$tu IP=$si ID=$ci\n");

        if($avp(debug)=="Y") { xlog("Failure Route nexbridge M=$rm RURI=$ru F=$fu T=$tu IP=$si ID=$ci\n"); }

        if ( t_check_status("486") )
        {
                if($avp(debug)=="Y") { xlog("$avp(carrier) failure block - 486 - Busy - $rU"); }
                t_reply("486", "Busy, Please try later");
                exit;
        }

        if ( t_check_status("404|484|403") )
        {
                if($avp(debug)=="Y") { xlog("nexbridge Sent 404 - Invalid"); }
                t_reply("404", "Invalid Number");
                exit;
        }

        if ( t_check_status("480") )
        {
                if($avp(debug)=="Y") { xlog("nexbridge Sent 480 - Temporarily Unavalible"); }
                t_reply("480", "Temporarily Unavalible");
                exit;
        }

        if ( t_check_status("408") )
        {
                if($avp(debug)=="Y") { xlog("nexbridge Sent 408 - Request Timeout - $rU"); }
                t_reply("408", "Request timeout");
                exit;
        }


 #Route to next gateway on failure
        if($avp(debug)=="Y") { xlog("$avp(carrier) failure block - About to try next GW"); }

        if(isflagset(AVAILFAILOVER)){
                if (use_next_gw()) {
                        if($avp(debug)=="Y") { xlog ("$avp(carrier) failure block next gateway $ru \n"); }
                        setflag(30);
                        t_on_failure("VoipTalkDialler");
                        switch($avp(dr_gwid))
                        {
                                case "10":
                                        route(voiptalk);
                                        break;
                                        case "9":
                                case "9":
                                        route(nexbridge);
                                        break;
                                case "15":
                                        route(VoipTalkDialler);
                                        break;
                                default:
                                        xlog("OUTBOUND Route block - Unable to find route\n");
                        }
                        exit;
                }
                else {
                        t_reply("503", "Service not available, no more gateways");
                        exit;
                }
        }
}

